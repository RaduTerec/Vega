Scope of course:
	* CRUD Operations
	* Forms
	* Filtering, sorting and pagination
	* Handling and logging errors
	* Toast notifications (not real-time)
	* Authentication and authorization
	* Preventing CSRF attacks
	* Uploading photos
	* Displaying charts
	* Dialog boxes
	
Out of scope:
	* Complex domain
	* Domain-driven Design ?????
	* Design patterns
	* Continous integration
	* Automated testing
	* Friendly UI
	
https://github.com/mosh-hamedani/vega/commits/master?before=4a09f50a4181d60134a9a816370b52276381c4d9+70&branch=master


	
==================================================================
Setup development environment

Install VS Code
---------------

Login with your account and all settings and extensions will be synchronized. Choose "Replace local" to copy all settings from the remote location over to local.

VS Code will sync: Settings, Shortcuts, User Snippets, Extensions, UI State

Extensions needed:
	* Angular Snippets Version 11
	* ASP.NET Helper 0.6.4
	* Auto Import 1.5.4
	* C# 1.23.11 & C# Extensions 1.3.1
	* Debugger for Firefox 2.9.4
	* Docker 1.14.0
	* npm 0.3.21
	* REST Client 0.24.5
	* SQL Server (mssql) 1.10.1

Install NPM
-----------

Install Node.js and NPM
https://www.npmjs.com/get-npm

Add following packages:
	* angular/cli
	
Commands are:
	* npm install -g --save-dev @angular/cli@8.3.29

Enable Policy Bypass to be able to run ng (angular CLI)
	* Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser
	
Create a .NetCore + Angular project
-----------------------------------
1. Create a new folder
2. Run the command: dotnet new angular

Note:
	* there are a lot of dotnet templates available. To see a full list run: dotnet new --list
	
Install MariaDB + HeidiSQL
--------------------------
Google it and go through the setup process. Simple and works just as well as SQL Express.

Simple run
----------
In the project directory type "dotnet run"



==================================================================
Dotnet structure

ClientApp
= folder where the Angular app is. Inside we have the app folder, the components, etc.

Controller
= folder for the Controller classes. Think MVC Controller.

Pages
= similar with Views.

wwwroot
= root folder of the final webpage. Instead of blacklisting files and folders, dotnetcore whitelists files & folders to be included.

appsettings.json
= similar to web.config, stores application settings. There is already a template defined for logging.

Program.cs
= defines the entry point of the application. Calls `CreateHostBuilder` which will initialize the Kestrel webserver. This webserver can run under both Windows and Linux.

Startup.cs
= defines the services which will run in the app and the request pipeline

ConfigureServices = used for dependency injection; If Controllers have dependencies which should be provided in the constructor, they will be registered here with their corresponding interface.

Configure = defines the request pipeline (which middleware will answer which request);
		  = ??? defines how the errors are logged.
		  

		  
==================================================================
Running the project

Terminal
--------
dotnet run
= runs the projects like Ctrl+F5 in VS

dotnet watch run
= when a .cs file is modified, the project is recompiled on the fly

VS Code
-------
similar to VS, with set Breakpoint, debug etc


 ----------
| !!! Note |
 ----------
To enable the debug environment, make sure you have the environment variable set, or it's value is created in .vscode->launch.json
ASPNETCORE_ENVIRONMENT="Development"



==================================================================
Creating the database

1. Installing Entity Framework Core CLI tools
---------------------------------------------
These tools allow you to adapt the DatabaseSchema to a real-world model. They perform design-time development tasks. For example, they create migrations, apply migrations, generate a schema based on a model and generate code for a model based on an existing database. The commands are an extension to dotnet command. They allow working with a DB without needing to go offline.
More information about EF Tools https://docs.microsoft.com/en-us/ef/core/cli/dotnet

To install EF Core Cli tools run:
	* dotnet tool install --global dotnet-ef
	
After installing the tools, open VS Code in the working folder, open terminal and install following packages to your project:
	* dotnet add package Microsoft.EntityFrameworkCore.Design

For SQL projects install:
	* dotnet add package Microsoft.EntityFrameworkCore.SqlServer
For MariaDb / MySql install:
	* dotnet add package Pomelo.EntityFrameworkCore.MySql
	
Note:
	a. Make sure the csproj is updated correctly after *removing* a package.

	
2. Creating the Models
----------------------
Most people follow the code first approach, where they define the model and then the schema.
So, to create the models, follow these steps:
	* Create a new folder in the project root called "models"
	* Add each model to your project, as a simple class with public properties.

Read about models in EF: https://docs.microsoft.com/en-us/ef/core/modeling/
	
Note:

!!!	a. Always create a relation using FK property + navigation property. Aka MakeID (FK property) + Make (navigation property).
	b. If working with a small dataset, it makes sense to include other models as private key in the larger model.
	   However, if the dataset is larger, work with separate models and it is advised to make 2 calls.	   
	c. If a model contains a collection of objects, initialize the collection in the constructor of the object. This prevents a NullRefException + it's that model's responsability.
	d. In the object inside the collection, it's advised to add a refernce to the parent so you can access it easier.
!!! e. Add Required and StringLength to make sure your fields are not too large.
	f. Verify if you can create a complexObject in EF Core. Something like Contact class inside Vehicle.
!!!	g. A many-to-many rel is implemented by having a collection of the other model in each class.
	h. Fluent API takes precedents and will override conventions and data annotations.
	
Read more about relations In EF Core:
	https://docs.microsoft.com/en-us/ef/core/modeling/relationships
	
Ex:
	public class Model
    {
        public long Id { get; set; }
		
		[Required]
        [StringLength(255)]
        public string Name { get; set; }
		
        public Make Make { get; set; }
        public long MakeId { get; set; }
    }
	
	public class Make
    {
        public long Id { get; set; }

        [Required]
        [StringLength(255)]
        public string Name { get; set; }
        
        public ICollection<Model> Models { get; }

        public Make()
        {
            Models = new Collection<Model>();
        }
    }

3. Create the DbContext
-----------------------
This context will be used to generate the migration schema. Instead of using a ConnectionString in the contructor, the new EF class uses a generic options class which takes as parameter the current context. The connection string will be passed as parameter through the options class.

	* In Models folder, add a new class "ProjectName_DbContext"
	* register it as a DbContext by defining following constructor:
		public VegaDbContext(DbContextOptions<VegaDbContext> options) : base(options)
	* For each model add a corresponding DbSet
	
4. Connection string
--------------------
To define the connection for our database go to `appsettings.json` and add:
	"ConnectionStrings": {
		"VegaConnectionString": "server=localhost; port=3306; database=vega; user=sa; password=MyComplexPassword!234"
	  }

5. Registering the service
--------------------------
In the Startup class, in the method `ConfigureService` add the dependency injection:
	services.AddDbContextPool<VegaDbContext>(options => options
                .UseMySql(
                    Configuration.GetConnectionString("VegaConnectionString"),
                    ServerVersion.AutoDetect(Configuration.GetConnectionString("VegaConnectionString"))
            ));
			
The `Configuration` objects is built by aggregation multiple configuration sources (appsetings.json, EnvironmentVariables etc). We can add a class "appsetings.Production.json" which will change the values for production.
			
6. Creating the Migration
-------------------------
We will use migrations to generate a clean DB schema, code-first approach. So, in VS Code terminal run:
	
	* dotnet ef migrations add InitialCreate
This command will create the intial commit of the database. It will automatically create a folder "Migrations" in the root folder of the project.

	* dotnet ef database update
This command will actually create the database you specified.

	* dotnet ef migrations remove
To remove the last migration.
	
	* dotnet ef update OlderMigrationName
To revert to a previous migration

Notes:
	a. If you need quick help use: dotnet ef --help
	b. Use baby-steps when creating migrations, because EF cannot distinguish between a column rename and drop.
	c. Review all migrations and make sure they don't affect your data.
	d. The Snapshot.cs is always in-sync with the migrations, so never delete the migrations without deleting all migrations.
!!!	e. If you specify an earlier migration, `dotnet ef database update migration_name` will *downgrade* the database to that version.

Reads:
More details about EF Core and migrations: https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/
Other read about configuring MariaDB: https://blog.georgekosmidis.net/2020/07/15/using-mariadb-in-an-aspnet-core-api-with-entity-framework-core/


7. Seeding the database
-----------------------
To seed the DB, create an empty migration and add SQL code to create records. It is important to add the code for downgrading the database, in our case to remove the added records. The SQL code to create records goes in the `Up` method, the one to downgrade the database in method `Down`.

protected override void Up(MigrationBuilder migrationBuilder)
{
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('Opel')");
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('VW')");
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('Peugeot')");
}

protected override void Down(MigrationBuilder migrationBuilder)
{
	migrationBuilder.Sql("DELETE FROM `vega`.`makes` WHERE `Name` IN ('Opel', 'VW', 'Peugeot')");
}

8. Publishing to Production
---------------------------
tun the commands:
	`set ASPNETCORE_ENVIRONMENT=Staging`
	`dotnet watch run`
	


==================================================================
Writing controllers

A controller is used to define and group a set of actions. An action (or action method) is a method on a controller which handles requests. Controllers logically group similar actions together. This aggregation of actions allows common sets of rules, such as routing, caching, and authorization, to be applied collectively. Requests are mapped to actions through routing.
Details here: https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-5.0

1. Creating a new controller
----------------------------
Follow these steps:
	* add a new class with the suffix "controller" inside the "Controller" folder
	* it should inherit from `ControllerBase`
	* define all required private objects and add them in the constructor. They will be called using DI.
	* make sure you define the Route and decorate the class & methods with appropiate verbs.
	
Note
!!!	* To be able to view child objects, use `include` in query.
	
Read more about routing here: https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-5.0
	
Ex:

	[ApiController]
    [Route("[controller]")]
    public class MakeController : ControllerBase
    {
        private VegaDbContext _vegaDbContext;
        private ILogger<MakeController> _logger;
  
        public MakeController(ILogger<MakeController> logger, VegaDbContext context)  
        {
            _logger = logger;
            _vegaDbContext = context;  
        }  
  
        [HttpGet]
        public async Task<IEnumerable<Make>> GetMakes()
        {
            return await _vegaDbContext.Makes.Include(f => f.Models).ToListAsync();
        }
    }
	
2. Prepare the DTO objects
--------------------------
The API will work with publicly available objects, not with the same objects like the ones in the DB. We do this to protect the API from changes and isolate what changes we show to the public.

`Model` becomes `ModelDTO` from below:

public class ModelDTO
{
	public long Id { get; set; }
	
	public string Name { get; set; }
}

3. Add AutoMapper
-----------------
This package deals with mapping your internal objects to DTO, as explained here: https://codewithmukesh.com/blog/automapper-in-aspnet-core/
	* dotnet add package AutoMapper
	* dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
	
Add the dependency injection in services:
	* services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
	
Create a mapping profile in the new `Mappings` folder in the root of the project:
	public class MappingProfile : Profile
	{
		public MappingProfile()
		{
			CreateMap<Make, MakeDTO>();
			CreateMap<Model, ModelDTO>();
		}
	}

Change the Controller to work with the DTO objects.
	public async Task<IEnumerable<MakeDTO>> GetMakes()
	{
		var makes = await _vegaDbContext.Makes.Include(f => f.Models).ToListAsync();

		return _mapper.Map<IEnumerable<MakeDTO>>(makes);
	}


	
==================================================================
Implementing CRUD Operations

We don't like loops in the DB, so if you need a relation to both make and model, make the relation just to model, because you can determine the make from the model.

1. Creating the API Data Transfer Objects
-----------------------------------------
There are some properties which you don't want exposed on the API, like LastUpdate.
Some other properties can be simplified so we work with simple objects instead of complex ones. (ex work with featureID instead of the whole feature).
Some properties can be grouped together so that they belong to a single class, even if in the DB they are in the parent class.

Note:
!!!	a. All DTO arrays need a setter even if they are instantiated in the constructor. Without a setter, the browser cannot set the objects' content.

public class Vehicle
{
	public long Id { get; set; }

	public long ModelId { get; set; }
	[Required]
	public Model Model { get; set; }

	[Required]
	public bool IsRegistered { get; set; }

	[Required]
	public ICollection<VehicleFeature> Features { get; }

	[Required]
	[StringLength(255)]
	public string ContactName { get; set; }

	[Required]
	[StringLength(255)]
	public string ContactEmail { get; set; }

	[Required]
	[StringLength(255)]
	public string ContactPhone { get; set; }

	public DateTime LastUpdate { get; set; }

	public Vehicle()
	{
		Features = new Collection<VehicleFeature>();
	}
}

DTO classes:

public class ContactDTO
{
	public string Name { get; set; }
	public string Email { get; set; }
	public string Phone { get; set; }
}

public class VehicleDTO
{
	public long Id { get; set; }
	public long ModelId { get; set; }
	public bool IsRegistered { get; set; }
	public ContactDTO Contact { get; set; }
	public ICollection<int> Features { get; set; }

	public VehicleDTO()
	{
		Features = new Collection<int>();
	}
}

2. Creating complex mappings
----------------------------
Since we created a DTO which has a child DTO, we need to tell the mapper how to associate the properties from the child DTO with the properties from the model.
By using `ReverseMap`, the mapper will know automatically how to map `ContactName` with `Contact.Name`.

// Domain to API and API to Domain
CreateMap<Vehicle, SaveVehicleDTO>()
	.ForMember(vDto => vDto.Contact, opt => opt.MapFrom(v => new ContactDTO
	{
		Name = v.ContactName,
		Email = v.ContactEmail,
		Phone = v.ContactPhone
	}))
	.ForMember(vDto => vDto.Features, opt => opt.MapFrom(v => v.Features.Select(vf => vf.FeatureId)));

Because in the Domain-to-API mapping we simplify `Features` to `long array`, in the API-to-Domain mapping, we remove `Features` member, to populate it differently.
Since we want the mapper to map the API to domain model internally, we had to introduce the `VehicleFeature` join-table class.

// API to Domain
CreateMap<SaveVehicleDTO, Vehicle>()
	.ForMember(v => v.Id, opt => opt.Ignore())
	.ForMember(v => v.ContactName, opt => opt.MapFrom(vDto => vDto.Contact.Name))
	.ForMember(v => v.ContactEmail, opt => opt.MapFrom(vDto => vDto.Contact.Email))
	.ForMember(v => v.ContactPhone, opt => opt.MapFrom(vDto => vDto.Contact.Phone))
	.ForMember(v => v.Features, opt => opt.Ignore())
	
Important!!
To associate the features from the API back to the domain model, we have to:
	- remove all deleted features
	- add all new features as domain features back to the object.
To achieve this, we use the method `AfterMap`

.AfterMap((vr, v) =>
{
	// Remove unselected features
	var removedFeatures = v.Features.Where(f => !vr.Features.Contains(f.FeatureId)).ToList();
	foreach (var feature in removedFeatures)
	{
		v.Features.Remove(feature);
	}

	// Add new features
	var addedFeatures = vr.Features
							.Where(id => !v.Features.Any(f => f.FeatureId == id))
							.Select(id => new VehicleFeature { FeatureId = id }).ToList();
	foreach (var feature in addedFeatures)
	{
		v.Features.Add(feature);
	}
});

3. Implementing validation
--------------------------
When using `ApiController` classes, the Model validation is done automatically based on the data annotations of the models. It is therefore crucial to define them properly. See: https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0

Notes
!!!	a. Use FluentAPI in Domain Models and Data Annotations in DTO Models. Why? With FluentAPI you can define complex relationships which cannot be defined by Data Annotations.
	b. In public APIs you could define your model errors inside the Data Annotation.
		[StringLength(8, ErrorMessage = "Name length can't be more than 8.")]
		
ContactDTO becomes:
public class ContactDTO
{
	[Required]
	[StringLength(255)]
	public string Name { get; set; }

	[Required]
	[EmailAddress]
	[StringLength(255)]
	public string Email { get; set; }

	[Required]
	[Phone]
	[StringLength(255)]
	public string Phone { get; set; }
}
	
4. Actual CRUD Operations
-------------------------
If possible use `FindAsync` because it's up to 1000 times faster than `SingleOrDefaultAsync`
`SingleOrDefaultAsync` will return a default null object if not found, which can be used for validating a request.
Only in the `Insert` method verify if the id of the object is null.

Use the mapper to copy the properties from the API to the domain model.
	_mapper.Map(vehicleDTO, vehicleToUpdate);
	
Even when deleting an object, retrieve it from the DB to make sure the object exists.



==================================================================
Refactoring towards clean architecture

1. DTOs revisited
-----------------
You should use different DTOs based on their purpose:
	- one for reading, one for sending data to the controller.
	- encapsulate fields with the same purpose in a single DTO (ex: contactDTO)
See `VehicleDTO` vs `SaveVehicleDTO`.

Why use DTOs?
	- prevent API contract from breaking
	- protect site from over-posting (not send LastUpdate)
	
Group simple DTOs together. Ex Model, Make and Feature all use a `KeyValuePair {ID, Name}`. Therefore, remove properites and leave only KeyValuePair.

public class MakeDTO : KeyValuePairDTO
{
	public ICollection<KeyValuePairDTO> Models { get; }

	public MakeDTO()
	{
		Models = new Collection<KeyValuePairDTO>();
	}
}
	
To eager load a property in the model, use `ThenInclude`:
await _vegaDbContext.Vehicles
	.Include(v => v.Features)
		.ThenInclude(vf => vf.Feature)
	.Include(v => v.Model)
		.ThenInclude(m => m.Make)
	.SingleOrDefaultAsync(v => v.Id.Equals(Id));

2. Repository pattern
--------------------------------------
REPOSITORY = COLLECTION(Obj)
Think of a repository as `List<string>()`. A list doesn't have methods for saving or updating objects.

Definition
	= Mediates between the domain and data mapping layers, acting like an in-memory collection of domain objects.

Purpose of a repository:
	a. Reduce the number of database queries.
	b. Decouple code from ORM.
	c(?). Help with unit testing.

A repository has following types of methods
	Get(obj)
	Add(obj)
	Find(Obj)
	Remove(obj)
	
Why DbContext and DbSet are not implementations of Repositories:
	a. DbContext returns `IQueryable`, which still encourages fat queries.
	b. DbContext is a type defined by EF, so it's tightly coupled.
	
Implementation of the repository pattern

	IRepository <-------------- IVehicleRepository
		^								^
		|								|
	Repository	<-------------- VehicleRepository
	
The interface `IRepository` contains the general signatures for a repository: Get, Add, Find, Remove.
The `Repository` class implements above methods, with a generic context.
`IVehicleRepository` interface adds signatures for specific repository methods: GetWithFeatures, GetWithRelated, GetAll
`VehicleRepository` will inherit the methods from `Repository` and implement the specific methods from `IVehicleRepository`.

Use design patterns when necessary, not as deodorant for smelly code!

We use the repository pattern to decouple the controller from ORM:
	public VehicleController(IMapper mapper, IVehicleRepository vehicleRepository, IUnitOfWork unitOfWork)

In case of the Vega app, since we have only 1 repository (for now), we start with just a simple interface and implementation.

public interface IVehicleRepository
{
	public Task<Vehicle> Get(long id);
	public Task<Vehicle> GetWithRelated(long id);
	public Task<Vehicle> GetWithFeatures(long id);
	public Task<IEnumerable<Vehicle>> GetAll();
	public Task AddAsync(Vehicle vehicle);
	public void Remove(Vehicle vehicle);
}

Note
!!!	a. When registering `IVehicleRepository`, since the DbContext is scoped, we will also register it as scoped.
	b. Possible service registrations:
		1. Transient = a separate instance of repository for every use.
		2. Scoped = a single instance of repository for each request.
		3. Singleton = a single instance of the repository during application lifecycle.

3. Unit of work pattern
-----------------------
Unit of work = handles the transaction of the repositories registered for it.

Definition
	= Maintains a list of objects affected by a transaction and coordinates the writing out of changes.
	
A unit of work contains:
	- relevant repositories (ex: vehicleRepo, featureRepo, etc)
	- a Complete method
	
The `Complete` method essentially saves changes in the DB.
In our case, since we use only `VehicleRepository`, we only added the `Complete` method in the UnitOfWork.

3. Dependency inversion principle
---------------------------------
Higher level modules should not depend on low-level modules.
Both should depend on abstractions.

Ex: Controller ------> IRepository <------- Repository
Now both Controller and Repository depend on Low-level module, since IRepository is in the core module.

!!! Why? To minimize the impact of changes.
!!! Interface = CONTRACT between the IMPLEMENTATION and the CONSUMER.

4. Layers vs tiers
------------------
Layers = folders like Presentation, Business Logic, Data access layer.
Tiers = PHYSICAL DISTRIBUTION OF THE SOFTWARE: client machine (on browser), web server and database.

An application is decoupled and well-written if it the dependency inversion principle is respected, if it's easy to change the ORM etc.
An application is not decoupled if it uses 3 layers.

Best methods are methods with no parameters (Uncle Bob)