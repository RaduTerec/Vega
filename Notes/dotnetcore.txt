Scope of course:
	* CRUD Operations
	* Forms
	* Filtering, sorting and pagination
	* Handling and logging errors
	* Toast notifications (not real-time)
	* Authentication and authorization
	* Preventing CSRF attacks
	* Uploading photos
	* Displaying charts
	* Dialog boxes
	
Out of scope:
	* Complex domain
	* Domain-driven Design ?????
	* Design patterns
	* Continous integration
	* Automated testing
	* Friendly UI
	
https://github.com/mosh-hamedani/vega/commits/master?before=4a09f50a4181d60134a9a816370b52276381c4d9+35&branch=master


	
==================================================================
Setup development environment

Install VS Code
---------------

Login with your account and all settings and extensions will be synchronized. Choose "Replace local" to copy all settings from the remote location over to local.

VS Code will sync: Settings, Shortcuts, User Snippets, Extensions, UI State

Extensions needed:
	* Angular Snippets Version 11
	* ASP.NET Helper 0.6.4
	* Auto Import 1.5.4
	* C# 1.23.11 & C# Extensions 1.3.1
	* Debugger for Firefox 2.9.4
	* Docker 1.14.0
	* npm 0.3.21
	* REST Client 0.24.5
	* SQL Server (mssql) 1.10.1

Install NPM
-----------

Install Node.js and NPM
https://www.npmjs.com/get-npm

Add following packages:
	* angular/cli
	
Commands are:
	* npm install -g --save-dev @angular/cli@8.3.29

Enable Policy Bypass to be able to run ng (angular CLI)
	* Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser
	
Create a .NetCore + Angular project
-----------------------------------
1. Create a new folder
2. Run the command: dotnet new angular

Note:
	* there are a lot of dotnet templates available. To see a full list run: dotnet new --list
	
Install MariaDB + HeidiSQL
--------------------------
Google it and go through the setup process. Simple and works just as well as SQL Express.

Simple run
----------
In the project directory type "dotnet run"



==================================================================
Dotnet structure

ClientApp
= folder where the Angular app is. Inside we have the app folder, the components, etc.

Controller
= folder for the Controller classes. Think MVC Controller.

Pages
= similar with Views.

wwwroot
= root folder of the final webpage. Instead of blacklisting files and folders, dotnetcore whitelists files & folders to be included.

appsettings.json
= similar to web.config, stores application settings. There is already a template defined for logging.

Program.cs
= defines the entry point of the application. Calls `CreateHostBuilder` which will initialize the Kestrel webserver. This webserver can run under both Windows and Linux.

Startup.cs
= defines the services which will run in the app and the request pipeline

ConfigureServices = used for dependency injection; If Controllers have dependencies which should be provided in the constructor, they will be registered here with their corresponding interface.

Configure = defines the request pipeline (which middleware will answer which request);
		  = ??? defines how the errors are logged.
		  

		  
==================================================================
Running the project

Terminal
--------
dotnet run
= runs the projects like Ctrl+F5 in VS

dotnet watch run
= when a .cs file is modified, the project is recompiled on the fly

VS Code
-------
similar to VS, with set Breakpoint, debug etc


 ----------
| !!! Note |
 ----------
To enable the debug environment, make sure you have the environment variable set, or it's value is created in .vscode->launch.json
ASPNETCORE_ENVIRONMENT="Development"



==================================================================
Creating the database

1. Installing Entity Framework Core CLI tools
---------------------------------------------
These tools allow you to adapt the DatabaseSchema to a real-world model. They perform design-time development tasks. For example, they create migrations, apply migrations, generate a schema based on a model and generate code for a model based on an existing database. The commands are an extension to dotnet command. They allow working with a DB without needing to go offline.
More information about EF Tools https://docs.microsoft.com/en-us/ef/core/cli/dotnet

To install EF Core Cli tools run:
	* dotnet tool install --global dotnet-ef
	
To update EF Core Cli tools run:
	* dotnet tool update --global dotnet-ef
	
After installing the tools, open VS Code in the working folder, open terminal and install following packages to your project:
	* dotnet add package Microsoft.EntityFrameworkCore.Design

For SQL projects install:
	* dotnet add package Microsoft.EntityFrameworkCore.SqlServer
For MariaDb / MySql install:
	* dotnet add package Pomelo.EntityFrameworkCore.MySql
	
Note:
	a. Make sure the csproj is updated correctly after *removing* a package.

	
2. Creating the Models
----------------------
Most people follow the code first approach, where they define the model and then the schema.
So, to create the models, follow these steps:
	* Create a new folder in the project root called "models"
	* Add each model to your project, as a simple class with public properties.

Read about models in EF: https://docs.microsoft.com/en-us/ef/core/modeling/
	
Note:

!!!	a. Always create a relation using FK property + navigation property. Aka MakeID (FK property) + Make (navigation property).
	b. If working with a small dataset, it makes sense to include other models as private key in the larger model.
	   However, if the dataset is larger, work with separate models and it is advised to make 2 calls.	   
	c. If a model contains a collection of objects, initialize the collection in the constructor of the object. This prevents a NullRefException + it's that model's responsability.
	d. In the object inside the collection, it's advised to add a refernce to the parent so you can access it easier.
!!! e. Add Required and StringLength to make sure your fields are not too large.
	f. Verify if you can create a complexObject in EF Core. Something like Contact class inside Vehicle.
!!!	g. A many-to-many rel is implemented by having a collection of the other model in each class.
	h. Fluent API takes precedents and will override conventions and data annotations.
	
Read more about relations In EF Core:
	https://docs.microsoft.com/en-us/ef/core/modeling/relationships
	
Ex:
	public class Model
    {
        public long Id { get; set; }
		
		[Required]
        [StringLength(255)]
        public string Name { get; set; }
		
        public Make Make { get; set; }
        public long MakeId { get; set; }
    }
	
	public class Make
    {
        public long Id { get; set; }

        [Required]
        [StringLength(255)]
        public string Name { get; set; }
        
        public ICollection<Model> Models { get; }

        public Make()
        {
            Models = new Collection<Model>();
        }
    }

3. Create the DbContext
-----------------------
This context will be used to generate the migration schema. Instead of using a ConnectionString in the contructor, the new EF class uses a generic options class which takes as parameter the current context. The connection string will be passed as parameter through the options class.

	* In Models folder, add a new class "ProjectName_DbContext"
	* register it as a DbContext by defining following constructor:
		public VegaDbContext(DbContextOptions<VegaDbContext> options) : base(options)
	* For each model add a corresponding DbSet
	
4. Connection string
--------------------
To define the connection for our database go to `appsettings.json` and add:
	"ConnectionStrings": {
		"VegaConnectionString": "server=localhost; port=3306; database=vega; user=sa; password=MyComplexPassword!234"
	  }

5. Registering the service
--------------------------
In the Startup class, in the method `ConfigureService` add the dependency injection:
	services.AddDbContextPool<VegaDbContext>(options => options
                .UseMySql(
                    Configuration.GetConnectionString("VegaConnectionString"),
                    ServerVersion.AutoDetect(Configuration.GetConnectionString("VegaConnectionString"))
            ));
			
The `Configuration` objects is built by aggregation multiple configuration sources (appsetings.json, EnvironmentVariables etc). We can add a class "appsetings.Production.json" which will change the values for production.
			
6. Creating the Migration
-------------------------
We will use migrations to generate a clean DB schema, code-first approach. So, in VS Code terminal run:
	
	* dotnet ef migrations add InitialCreate
This command will create the intial commit of the database. It will automatically create a folder "Migrations" in the root folder of the project.

	* dotnet ef database update
This command will actually create the database you specified.

	* dotnet ef migrations remove
To remove the last migration.
	
	* dotnet ef update OlderMigrationName
To revert to a previous migration

Notes:
	a. If you need quick help use: dotnet ef --help
	b. Use baby-steps when creating migrations, because EF cannot distinguish between a column rename and drop.
	c. Review all migrations and make sure they don't affect your data.
	d. The Snapshot.cs is always in-sync with the migrations, so never delete the migrations without deleting all migrations.
!!!	e. If you specify an earlier migration, `dotnet ef database update migration_name` will *downgrade* the database to that version.

Reads:
More details about EF Core and migrations: https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/
Other read about configuring MariaDB: https://blog.georgekosmidis.net/2020/07/15/using-mariadb-in-an-aspnet-core-api-with-entity-framework-core/


7. Seeding the database
-----------------------
To seed the DB, create an empty migration and add SQL code to create records. It is important to add the code for downgrading the database, in our case to remove the added records. The SQL code to create records goes in the `Up` method, the one to downgrade the database in method `Down`.

protected override void Up(MigrationBuilder migrationBuilder)
{
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('Opel')");
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('VW')");
	migrationBuilder.Sql("INSERT INTO `vega`.`makes` (`Name`) VALUES ('Peugeot')");
}

protected override void Down(MigrationBuilder migrationBuilder)
{
	migrationBuilder.Sql("DELETE FROM `vega`.`makes` WHERE `Name` IN ('Opel', 'VW', 'Peugeot')");
}

8. Publishing to Production
---------------------------
tun the commands:
	`set ASPNETCORE_ENVIRONMENT=Staging`
	`dotnet watch run`
	


==================================================================
Writing controllers

A controller is used to define and group a set of actions. An action (or action method) is a method on a controller which handles requests. Controllers logically group similar actions together. This aggregation of actions allows common sets of rules, such as routing, caching, and authorization, to be applied collectively. Requests are mapped to actions through routing.
Details here: https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-5.0

1. Creating a new controller
----------------------------
Follow these steps:
	* add a new class with the suffix "controller" inside the "Controller" folder
	* it should inherit from `ControllerBase`
	* define all required private objects and add them in the constructor. They will be called using DI.
	* make sure you define the Route and decorate the class & methods with appropiate verbs.
	
Note
!!!	* To be able to view child objects, use `include` in query.
	
Read more about routing here: https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-5.0
	
Ex:

	[ApiController]
    [Route("[controller]")]
    public class MakeController : ControllerBase
    {
        private VegaDbContext _vegaDbContext;
        private ILogger<MakeController> _logger;
  
        public MakeController(ILogger<MakeController> logger, VegaDbContext context)  
        {
            _logger = logger;
            _vegaDbContext = context;  
        }  
  
        [HttpGet]
        public async Task<IEnumerable<Make>> GetMakes()
        {
            return await _vegaDbContext.Makes.Include(f => f.Models).ToListAsync();
        }
    }
	
2. Prepare the DTO objects
--------------------------
The API will work with publicly available objects, not with the same objects like the ones in the DB. We do this to protect the API from changes and isolate what changes we show to the public.

`Model` becomes `ModelDTO` from below:

public class ModelDTO
{
	public long Id { get; set; }
	
	public string Name { get; set; }
}

3. Add AutoMapper
-----------------
This package deals with mapping your internal objects to DTO, as explained here: https://codewithmukesh.com/blog/automapper-in-aspnet-core/
	* dotnet add package AutoMapper
	* dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
	
Add the dependency injection in services:
	* services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
	
Create a mapping profile in the new `Mappings` folder in the root of the project:
	public class MappingProfile : Profile
	{
		public MappingProfile()
		{
			CreateMap<Make, MakeDTO>();
			CreateMap<Model, ModelDTO>();
		}
	}

Change the Controller to work with the DTO objects.
	public async Task<IEnumerable<MakeDTO>> GetMakes()
	{
		var makes = await _vegaDbContext.Makes.Include(f => f.Models).ToListAsync();

		return _mapper.Map<IEnumerable<MakeDTO>>(makes);
	}


	
==================================================================
Implementing CRUD Operations

We don't like loops in the DB, so if you need a relation to both make and model, make the relation just to model, because you can determine the make from the model.

1. Creating the API Data Transfer Objects
-----------------------------------------
There are some properties which you don't want exposed on the API, like LastUpdate.
Some other properties can be simplified so we work with simple objects instead of complex ones. (ex work with featureID instead of the whole feature).
Some properties can be grouped together so that they belong to a single class, even if in the DB they are in the parent class.

Note:
!!!	a. All DTO arrays need a setter even if they are instantiated in the constructor. Without a setter, the browser cannot set the objects' content.

public class Vehicle
{
	public long Id { get; set; }

	public long ModelId { get; set; }
	[Required]
	public Model Model { get; set; }

	[Required]
	public bool IsRegistered { get; set; }

	[Required]
	public ICollection<VehicleFeature> Features { get; }

	[Required]
	[StringLength(255)]
	public string ContactName { get; set; }

	[Required]
	[StringLength(255)]
	public string ContactEmail { get; set; }

	[Required]
	[StringLength(255)]
	public string ContactPhone { get; set; }

	public DateTime LastUpdate { get; set; }

	public Vehicle()
	{
		Features = new Collection<VehicleFeature>();
	}
}

DTO classes:

public class ContactDTO
{
	public string Name { get; set; }
	public string Email { get; set; }
	public string Phone { get; set; }
}

public class VehicleDTO
{
	public long Id { get; set; }
	public long ModelId { get; set; }
	public bool IsRegistered { get; set; }
	public ContactDTO Contact { get; set; }
	public ICollection<int> Features { get; set; }

	public VehicleDTO()
	{
		Features = new Collection<int>();
	}
}

2. Creating complex mappings
----------------------------
Since we created a DTO which has a child DTO, we need to tell the mapper how to associate the properties from the child DTO with the properties from the model.
By using `ReverseMap`, the mapper will know automatically how to map `ContactName` with `Contact.Name`.

// Domain to API and API to Domain
CreateMap<Vehicle, SaveVehicleDTO>()
	.ForMember(vDto => vDto.Contact, opt => opt.MapFrom(v => new ContactDTO
	{
		Name = v.ContactName,
		Email = v.ContactEmail,
		Phone = v.ContactPhone
	}))
	.ForMember(vDto => vDto.Features, opt => opt.MapFrom(v => v.Features.Select(vf => vf.FeatureId)));

Because in the Domain-to-API mapping we simplify `Features` to `long array`, in the API-to-Domain mapping, we remove `Features` member, to populate it differently.
Since we want the mapper to map the API to domain model internally, we had to introduce the `VehicleFeature` join-table class.

// API to Domain
CreateMap<SaveVehicleDTO, Vehicle>()
	.ForMember(v => v.Id, opt => opt.Ignore())
	.ForMember(v => v.ContactName, opt => opt.MapFrom(vDto => vDto.Contact.Name))
	.ForMember(v => v.ContactEmail, opt => opt.MapFrom(vDto => vDto.Contact.Email))
	.ForMember(v => v.ContactPhone, opt => opt.MapFrom(vDto => vDto.Contact.Phone))
	.ForMember(v => v.Features, opt => opt.Ignore())
	
Important!!
To associate the features from the API back to the domain model, we have to:
	- remove all deleted features
	- add all new features as domain features back to the object.
To achieve this, we use the method `AfterMap`

.AfterMap((vr, v) =>
{
	// Remove unselected features
	var removedFeatures = v.Features.Where(f => !vr.Features.Contains(f.FeatureId)).ToList();
	foreach (var feature in removedFeatures)
	{
		v.Features.Remove(feature);
	}

	// Add new features
	var addedFeatures = vr.Features
							.Where(id => !v.Features.Any(f => f.FeatureId == id))
							.Select(id => new VehicleFeature { FeatureId = id }).ToList();
	foreach (var feature in addedFeatures)
	{
		v.Features.Add(feature);
	}
});

3. Implementing validation
--------------------------
When using `ApiController` classes, the Model validation is done automatically based on the data annotations of the models. It is therefore crucial to define them properly. See: https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-5.0

Notes
!!!	a. Use FluentAPI in Domain Models and Data Annotations in DTO Models. Why? With FluentAPI you can define complex relationships which cannot be defined by Data Annotations.
	b. In public APIs you could define your model errors inside the Data Annotation.
		[StringLength(8, ErrorMessage = "Name length can't be more than 8.")]
		
ContactDTO becomes:
public class ContactDTO
{
	[Required]
	[StringLength(255)]
	public string Name { get; set; }

	[Required]
	[EmailAddress]
	[StringLength(255)]
	public string Email { get; set; }

	[Required]
	[Phone]
	[StringLength(255)]
	public string Phone { get; set; }
}
	
4. Actual CRUD Operations
-------------------------
If possible use `FindAsync` because it's up to 1000 times faster than `SingleOrDefaultAsync`
`SingleOrDefaultAsync` will return a default null object if not found, which can be used for validating a request.
Only in the `Insert` method verify if the id of the object is null.

Use the mapper to copy the properties from the API to the domain model.
	_mapper.Map(vehicleDTO, vehicleToUpdate);
	
Even when deleting an object, retrieve it from the DB to make sure the object exists.



==================================================================
Refactoring towards clean architecture

1. DTOs revisited
-----------------
You should use different DTOs based on their purpose:
	- one for reading, one for sending data to the controller.
	- encapsulate fields with the same purpose in a single DTO (ex: contactDTO)
See `VehicleDTO` vs `SaveVehicleDTO`.

Why use DTOs?
	- prevent API contract from breaking
	- protect site from over-posting (not send LastUpdate)
	
Group simple DTOs together. Ex Model, Make and Feature all use a `KeyValuePair {ID, Name}`. Therefore, remove properites and leave only KeyValuePair.

public class MakeDTO : KeyValuePairDTO
{
	public ICollection<KeyValuePairDTO> Models { get; }

	public MakeDTO()
	{
		Models = new Collection<KeyValuePairDTO>();
	}
}
	
To eager load a property in the model, use `ThenInclude`:
await _vegaDbContext.Vehicles
	.Include(v => v.Features)
		.ThenInclude(vf => vf.Feature)
	.Include(v => v.Model)
		.ThenInclude(m => m.Make)
	.SingleOrDefaultAsync(v => v.Id.Equals(Id));

2. Repository pattern
--------------------------------------
REPOSITORY = COLLECTION(Obj)
Think of a repository as `List<string>()`. A list doesn't have methods for saving or updating objects.

Definition
	= Mediates between the domain and data mapping layers, acting like an in-memory collection of domain objects.

Purpose of a repository:
	a. Reduce the number of database queries.
	b. Decouple code from ORM.
	c(?). Help with unit testing.

A repository has following types of methods
	Get(obj)
	Add(obj)
	Find(Obj)
	Remove(obj)
	
Why DbContext and DbSet are not implementations of Repositories:
	a. DbContext returns `IQueryable`, which still encourages fat queries.
	b. DbContext is a type defined by EF, so it's tightly coupled.
	
Implementation of the repository pattern

	IRepository <-------------- IVehicleRepository
		^								^
		|								|
	Repository	<-------------- VehicleRepository
	
The interface `IRepository` contains the general signatures for a repository: Get, Add, Find, Remove.
The `Repository` class implements above methods, with a generic context.
`IVehicleRepository` interface adds signatures for specific repository methods: GetWithFeatures, GetWithRelated, GetAll
`VehicleRepository` will inherit the methods from `Repository` and implement the specific methods from `IVehicleRepository`.

Use design patterns when necessary, not as deodorant for smelly code!

We use the repository pattern to decouple the controller from ORM:
	public VehicleController(IMapper mapper, IVehicleRepository vehicleRepository, IUnitOfWork unitOfWork)

In case of the Vega app, since we have only 1 repository (for now), we start with just a simple interface and implementation.

public interface IVehicleRepository
{
	public Task<Vehicle> Get(long id);
	public Task<Vehicle> GetWithRelated(long id);
	public Task<Vehicle> GetWithFeatures(long id);
	public Task<IEnumerable<Vehicle>> GetAll();
	public Task AddAsync(Vehicle vehicle);
	public void Remove(Vehicle vehicle);
}

Note
!!!	a. When registering `IVehicleRepository`, since the DbContext is scoped, we will also register it as scoped.
	b. Possible service registrations:
		1. Transient = a separate instance of repository for every use.
		2. Scoped = a single instance of repository for each request.
		3. Singleton = a single instance of the repository during application lifecycle.

3. Unit of work pattern
-----------------------
Unit of work = handles the transaction of the repositories registered for it.

Definition
	= Maintains a list of objects affected by a transaction and coordinates the writing out of changes.
	
A unit of work contains:
	- relevant repositories (ex: vehicleRepo, featureRepo, etc)
	- a Complete method
	
The `Complete` method essentially saves changes in the DB.
In our case, since we use only `VehicleRepository`, we only added the `Complete` method in the UnitOfWork.

3. Dependency inversion principle
---------------------------------
Higher level modules should not depend on low-level modules.
Both should depend on abstractions.

Ex: Controller ------> IRepository <------- Repository
Now both Controller and Repository depend on Low-level module, since IRepository is in the core module.

!!! Why? To minimize the impact of changes.
!!! Interface = CONTRACT between the IMPLEMENTATION and the CONSUMER.

4. Layers vs tiers
------------------
Layers = folders like Presentation, Business Logic, Data access layer.
Tiers = PHYSICAL DISTRIBUTION OF THE SOFTWARE: client machine (on browser), web server and database.

An application is decoupled and well-written if it the dependency inversion principle is respected, if it's easy to change the ORM etc.
An application is not decoupled if it uses 3 layers.

Best methods are methods with no parameters (Uncle Bob)



==================================================================
Filtering, Sorting, Pagination

1. Filtering
------------
When using filters, use a separate model for your C# code vs Client code. See how we handle display of models.
	!!Change the repository to return a query and make changes on that query before running it.

It is alright to change the Repository contract to receive the filter paramater.

There is an issue with HttpGet:
	- to make HttpGet work with complex objects, define the place from where the object is read. Eg:

public async Task<IEnumerable<VehicleDTO>> Get([FromQuery] VehicleQueryDTO vehicleQueryDTO)

	
2. Sorting
----------
For sorting it's enough to use a string for the Column which will be sorted and a boolean for the direction.

Use a dictionary with <string, Expression> to map a column with it's expression value.

To make the code reusable, define extension methods for applying sorting.
The extension methods should use generics.

public static IQueryable<T> ApplyOrdering<T>(this IQueryable<T> query, IQueryObject sortQuery, Dictionary<string, Expression<Func<T, object>>> columnsMap)
{
	if (string.IsNullOrEmpty(sortQuery.SortBy) || !columnsMap.ContainsKey(sortQuery.SortBy))
	{
		return query;
	}

	if (sortQuery.IsAscending)
	{
		return query.OrderBy(columnsMap[sortQuery.SortBy]);
	}
	else
	{
		return query.OrderByDescending(columnsMap[sortQuery.SortBy]);
	}
}

3. Pagination
-------------
Use extension methods for pagination as well.

public static IQueryable<T> ApplyPaging<T>(this IQueryable<T> query, IQueryObject queryObj)
{
	if (queryObj.Page <= 0)
	{
		queryObj.Page = 1;
	}

	if (queryObj.PageSize <= 0)
	{
		queryObj.PageSize = 10;
	}

	return query.Skip((queryObj.Page - 1) * queryObj.PageSize).Take(queryObj.PageSize);
}

Return total number of objects together with IEnumerable<Vehicle> => it requires only 1 SQL statement.



==================================================================
Uploading photos

1. Upload Api
-------------
Photos have a different lifetime than other attributes, so they shouldn't be added to the "add vehicle" form.
For a lot of users it's not intuitive to hit save after uploading a photo. So, photos should be uploaded separately.

Notes
	a. To receive a file using POST use `IFormFile`. To upload several files use `IFormCollection`.
	b. To get info about HostingEnvironment use: IHostingEnvironment
!!!	c. Never trust a filename a user sends, because it can be subject to CSRF.
	d. Use GUID for new filenames + old filename extension.
	
2. Using configuration
----------------------
The settings in .NET Core are stored as JSON strings.
To read them, use 
	services.Configure<PhotoSettings>(Configuration.GetSection("PhotoSettings"));

To use them, inject `IOptionsSnapshot<PhotoSettings> options` in the constructor:
    public PhotosController(IHostingEnvironment host, IVehicleRepository repository, IUnitOfWork unitOfWork, IMapper mapper, IOptionsSnapshot<PhotoSettings> options)
    {
		this.photoSettings = options.Value;
		
		
==================================================================
Authentication and authorization

Use: https://codewithmukesh.com/blog/aspnet-core-api-with-jwt-authentication/
and https://medium.com/c-sharp-progarmming/asp-net-core-5-jwt-authentication-tutorial-with-example-api-aa59e80d02da

On the server:
	- protect API endpoints
	- define roles

On the client:
	- protect routes
	- show/hide DOM elements based on roles

1. Architecture
---------------
The client authenticates using username & password => the server responds with a JWT (JSON Web Token).
The JWT is signed and contains some basic data which can be used on further requests.
For each protected API call (use `Authorize` decorator), the server will determine the users' permissions based on JWT.

JWT is privately signed on the server using the servers' certificate.

Traditional Authentication		|		Modern Authentication
								|
* Authentication tickets		|	* JSON Web Tokens
* Sent using cookies			|	* Sent in the request header
								|	* Stored in the local storage
								
The modern authentication can be used for other types of clients like iOS or Android apps.

Infrastructure:
	* Registration form
	* Login form
	* Generate and validate tokens
	* Control access to API endpoints
	
2. JWT Structure
----------------
	* Header =  Contains the details on type of Token (JWT) + the algorithm used to sign the token (eg RSA, SHA256)
	* Payload = (most important part) contains the claims, which is the data we are trying to secure. Claims are details about the user, expiration time of the token, etc
	* Signature = it is an encryption between the header, payload and a secret key.

Visit https://jwt.io/#debugger-io to decode, verify and play around with JSON Web Tokens
	
3. Dependencies
---------------
Install nugget packages:
	dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
	dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
	dotnet restore
	
If you decide to use auth0, install npm packages:
	npm install auth0-lock angular2-jwt --save (?)
	
4. Implementation
-----------------
a) Configure settings you want added to your user:
To see the default options, visit: https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.entityframeworkcore.identityuser?view=aspnetcore-1.1

	public class VegaUser : IdentityUser
    {
        [StringLength(255)]
        public string Name { get; set; }
    }
	
b) Change the type of the DB Context to `IdentityDbContext<VegaUser>`. Make sure you call `base.OnModelCreating(modelBuilder);` in the overriden method:

	public class VegaDbContext : IdentityDbContext<VegaUser>
    {
        //DBSets

        public VegaDbContext(DbContextOptions<VegaDbContext> options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);            
            // fluent relationships
        }
    }
	
c) Seed the database with User roles and a user by editing VegaDBContext like below and generating a new migration.
The Guids can be obtained by running `Console.WriteLine(Guid.NewGuid());`.

	protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
		base.OnModelCreating(modelBuilder);

		modelBuilder.Entity<VehicleFeature>().HasKey(vf =>
		  new { vf.VehicleId, vf.FeatureId });

		this.SeedUsers(modelBuilder);
		this.SeedRoles(modelBuilder);
		this.SeedUserRoles(modelBuilder);
	}

	private void SeedUsers(ModelBuilder modelBuilder)
	{
		var adminUser = new VegaUser()
		{
			Id = "231f71e7-6ef6-4da3-be60-f6d09852b9c5",
			Name = "John Admin",
			UserName = "Admin",
			NormalizedUserName = "ADMIN",
			Email = "admin@vega.com",
			NormalizedEmail = "ADMIN@VEGA.COM",
			EmailConfirmed = true,
			LockoutEnabled = false,
			PhoneNumber = "0721458796",
			PhoneNumberConfirmed = true
		};

		var passwordHasher = new PasswordHasher<VegaUser>();
		adminUser.PasswordHash = passwordHasher.HashPassword(adminUser, "$3cUr3P@$$W0rD");

		modelBuilder.Entity<VegaUser>().HasData(adminUser);
	}

	private void SeedRoles(ModelBuilder modelBuilder)
	{
		modelBuilder.Entity<IdentityRole>().HasData(
			new IdentityRole() { Id = "bdea8fa1-fc61-423d-9832-ebf111d0cc1e", Name = "Admin", NormalizedName = "ADMIN", ConcurrencyStamp = "863315b4-55cb-4255-bd6f-01df1c8d988f" },
			new IdentityRole() { Id = "35dbbc4f-8843-49f7-b3e0-bde48d27b0ea", Name = "Moderator", NormalizedName = "MODERATOR", ConcurrencyStamp = "0aedbac8-e009-4de0-81cf-6e71cbc0d38d" },
			new IdentityRole() { Id = "a09194fc-1e87-4e14-a34f-414e10936f9e", Name = "User", NormalizedName = "USER", ConcurrencyStamp = "db023a06-a3db-4404-94b9-0c29ebf66fdb" }
			);
	}

	private void SeedUserRoles(ModelBuilder modelBuilder)
	{
		modelBuilder.Entity<IdentityUserRole<string>>().HasData(
			new IdentityUserRole<string>() { UserId = "231f71e7-6ef6-4da3-be60-f6d09852b9c5", RoleId = "bdea8fa1-fc61-423d-9832-ebf111d0cc1e" }
			);
	}


d) Add the JWT details to app config and add a class to read those settings.
	"JWTSettings": {
		"key": "C2CF5C8EA3F2448D8498DE4F55CA4",
		"Issuer": "VegaSecureApi",
		"Audience": "VegaUser",
		"DurationInMinutes": 30
	  },

Then, in Startup.cs register those settings using:
	services.Configure<JWTSettings>(Configuration.GetSection("JWTSettings"));


e) Define a UserController with methods to register a new user and to login. You should only register a regular user. You may anytime change the role of the user from the DB directly.
The login method should return an authentication response which contains the token used in further calls.

	public UserController(UserManager<VegaUser> userManager, IMapper mapper, IOptions<JWTSettings> jwtSettings)
	{
		_userManager = userManager;
		_mapper = mapper;
		_jwtSettings = jwtSettings.Value;
	}

	[HttpPost]
	public async Task<IActionResult> Register(UserDTO userDto)
	{
		var user = _mapper.Map<VegaUser>(userDto);

		var userWithSameEmail = await _userManager.FindByEmailAsync(userDto.Email);
		if (userWithSameEmail != null)
		{
			return BadRequest($"User with {userDto.Email} is already registered");
		}

		var result = await _userManager.CreateAsync(user, userDto.Password);
		if (result.Succeeded)
		{
			await _userManager.AddToRoleAsync(user, DefaultRole);
		}

		return Ok(userDto);
	}

	[HttpPut]
	public async Task<IActionResult> Login(LoginDTO login)
	{
		var authenticationResponse = new AuthenticationResponseDTO();
		var user = await _userManager.FindByEmailAsync(login.Email);
		if (user == null)
		{
			return BadRequest($"Could not authenticate {login.Email}");
		}

		if (await _userManager.CheckPasswordAsync(user, login.Password))
		{
			var jwtSecurityToken = await CreateJwtToken(user);
			authenticationResponse.Token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken);
			authenticationResponse.Email = user.Email;
			authenticationResponse.UserName = user.UserName;
			var rolesList = await _userManager.GetRolesAsync(user).ConfigureAwait(false);
			authenticationResponse.Roles = rolesList.ToList();
			return Ok(authenticationResponse);
		}            
		
		return BadRequest($"Could not authenticate {login.Email}");
	}
	

f) Configure Startup.cs
In the `Configure` method, between routing and endpoints, add:

	app.UseAuthentication();
	app.UseAuthorization();
	
We have to authenticate users before we can authorize anything, so keep the order above.
In the `ConfigureServices` method, add:

	services.Configure<JWTSettings>(Configuration.GetSection("JWT"));

	// User manager services
	services.AddIdentity<VegaUser, IdentityRole>().AddEntityFrameworkStores<VegaDbContext>();
	services.AddScoped<IUserService, UserService>();
	
	// other services
	
	// DB Context
	
	//Adding Athentication - JWT
	services.AddAuthentication(options =>
	{
		options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
		options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
	})
		.AddJwtBearer(o =>
		{
			o.RequireHttpsMetadata = false;
			o.SaveToken = false;
			o.TokenValidationParameters = new TokenValidationParameters
			{
				ValidateIssuerSigningKey = true,
				ValidateIssuer = true,
				ValidateAudience = true,
				ValidateLifetime = true,
				ClockSkew = TimeSpan.Zero,
				ValidIssuer = Configuration["JWT:Issuer"],
				ValidAudience = Configuration["JWT:Audience"],
				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["JWT:Key"]))
			};
		});
	
g) Write the client side:
	* authentication service which calls the Api
	* a userController which allows the user to enter his login / register a new user
	* integrate userController and service in app.module.ts and path.
See: https://mdbootstrap.com/docs/standard/extended/login/#!


==================================================================
Unit tests

We do not test repository classes, models, unit of work.
We test controller classes.
See: https://www.dotnetcurry.com/aspnet-core/1414/unit-testing-aspnet-core

To test a whole flow we should use integration tests, endâ€“to-end tests and load tests.

Each test class should follow: Arrange, Act, Assert
The naming should follow: Method_Returns_When
Each test should run independently from all other tests.

Example:

[Test]
public async Task TestGet_ReturnsVehicle_WhenIdExists()
{
	// Arrange
	var vehicleController = CreateDefaultVehicleController();
	const int vehicleId = 23;
	var vehicle = new Vehicle
	{
		Id = 23,
		ContactEmail = "maria@gmail.com",
		ContactName = "Maria",
		ContactPhone = "078970",
		IsRegistered = false,
		LastUpdate = DateTime.Today.Subtract(new TimeSpan(1, 0, 0, 0))
	};
	var vehicleDto = new VehicleDTO
	{
		Contact = new ContactDTO { Email = "maria@gmail.com", Name = "Maria", Phone = "078970" },
		Id = 23,
		IsRegistered = false,
		LastUpdate = DateTime.Today.Subtract(new TimeSpan(1, 0, 0, 0))
	};
	_vehicleRepositoryStub.Setup(repo => repo.GetWithRelated(vehicleId)).Returns(Task.FromResult(vehicle));

	// Act
	var result = await vehicleController.Get(vehicleId);

	// Assert
	Assert.IsNotNull(result.Result);
	Assert.IsInstanceOf<OkObjectResult>(result.Result);
	Assert.AreEqual(vehicleDto.Id, ((VehicleDTO)((OkObjectResult)result.Result).Value).Id);
	Assert.AreEqual(vehicleDto.Contact.Email, ((VehicleDTO)((OkObjectResult)result.Result).Value).Contact.Email);
	Assert.AreEqual(vehicleDto.LastUpdate, ((VehicleDTO)((OkObjectResult)result.Result).Value).LastUpdate);
}

Notes
	a. Consider:
		string s = (string)o;
		string s = o as string;
	   In the first case, the static cast will throw InvalidCastException if 'o' is not a string. Otherwise, assigns 'o' to 's', even if 'o' is null.
	   In the second as operator assigns 'null' to 's' if
			- 'o' is not a string or 
			- 'o' is 'null'.
	   For this reason, you cannot use it with value types (the operator could never return null in that case). Otherwise, assigns o to s.