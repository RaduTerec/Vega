Angular front-end

Register a new component in angular using:
	* ng g component vehicle-form -m .\app.module.ts

Create the new path in 
	* nav-menu.component.html
	
Create form with a div with class form-group. Inside the div create a label for 'model' and a select button with id = 'model'.
	* Write `form>did.form-group>label[for='model']+select[id='model']` and press 'Tab'
	
Read data from API using:
	import { HttpClient } from '@angular/common/http';
	import { Injectable } from '@angular/core';

	@Injectable()

	export class MakeService {
	  public makes: Make[];

	  constructor(private http: HttpClient) { }

	  getMakes() {
		return this.http.get<Make[]>('make');
	  }
	}

	interface Make {
	  name: string;
	  models: Model[];
	}

	interface Model {
	  name: string;
	}
	
In the component read from the service:
	export class VehicleFormComponent implements OnInit {

	  makes;
	  constructor(private makeservice: MakeService) { }

	  ngOnInit(): void {
		this.makeservice.getMakes()
		  .subscribe(makes => {
			this.makes = makes;
			//console.log("Makes: ", this.makes);
		  });    
	  }

	}
	
In the html read from the angular service:
	<div class="form-group">
        <label for="make">Make</label>
        <select id="make" class="form-control">
          <option value=""></option>
          <option *ngFor="let m of makes" value="{{ m.id }}">{{ m.name }}</option>
        </select>
    </div>
	
When we build forms with anuglar, there is always a control object associated with each input field.
This control object knows if this input field has been:
	* touched
	* dirty = value changed
	* valid
	* gives value
	
We can use Reactive Forms (written in code) or a Template-driven form (created via annotations).

Installing Toastr for notifications
-----------------------------------
Follow the steps on: https://www.npmjs.com/package/ngx-toastr

1. Go to ClientApp
	npm install ngx-toastr@10.1.0 --save
	npm install @angular/animations --save
	
2. In angular.json, find "styles" and add:
	"node_modules/ngx-toastr/toastr.css"
	
3. In app.module.ts import the 2 modules:
	import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
	import { ToastrModule } from 'ngx-toastr';
	
4. Use in whatever class is needed.

Error handling
--------------
All errors hit ErrorHandler. By deriving a class from ErrorHandler you can treat your custom exceptions.
When injecting Toastr service, we need to inject it manually, since ErrorHandler is loaded before the compiler learns what Toastr is.

Zones
-----
By running a function inside a zone you always have some code executed before and after the callback.
Angular runs all its code in zones. Actually it created a wrapper around zone.js, called ngZone.

var Zone = {
	run: function(callback) {
		if (this.beforeTask)
			this.beforeTask();
		
		callback();
		
		if (this.afterTask)
			this.afterTask();
	}
}

Zone.beforeTask = () => { console.log("Before"); }
Zone.afterTask = () => { console.log("After"); }
Zone.run = () => { console.log("Hello from the other side"); }

To run a code inside a zone and ensure it is called before Angulars' change detection algorithm, use:

To define a return type in angular:

getVehicles():Observable<Vehicle[]> {
    return this.http.get('/api/vehicle/') as Observable<Vehicle[]>;
  }
  
[routerLinkActiveOptions]="{exact: true}"
	-> matches the link only if exact match => won't highlight vehicles/new only vehicles
	
Use the class to pass state between calls. Eg use filter.make to remember what the filter contains.
Use client-side filtering for data with at most a couple hundred records. It's very fast, but can get out of hands for large data.
To apply filtering, at init store the whole list in a safe variable. Apply filtering on that list and assign the result.
See commit "client-side filtering".

Uploading files
---------------

Upload information is found in: `XMLHttpRequest`
To get the upload information during a post message, decorate post message with:

return this.http.post(`/api/vehicle/${vehicleId}/photos`, formData, {
      reportProgress: true,
      observe: 'events',
    });
	
In the code for the file upload:

uploadPhoto() {
    var nativeElement: HTMLInputElement = this.fileInput.nativeElement;
    var file = nativeElement.files[0];
    nativeElement.value = '';

    var upload = this.photoService.upload(this.vehicleId, file);

    this.uploadSub = upload.subscribe(resp => {
      this.zone.run(() => {
        if (resp.type === HttpEventType.UploadProgress) {
          var percentDone = Math.round(100 * resp.loaded / resp.total);
          this.uploadProgress = percentDone;
        }
        if (resp.type === HttpEventType.Response) {
          this.reset();
        }
      });
    })
  }

  cancelUpload() {
    this.uploadSub.unsubscribe();
    this.reset();
  }

  reset() {
    this.uploadProgress = null;
    this.uploadSub = null;
  }
  
  
Path guards
-----------
When registering components, you can define when that component can be accessed.
To define that, you need to create a class which implement `CanActivate` interface.

@Injectable()
export class EditVehicleGuard implements CanActivate {

    constructor(private router: Router,
        private auth: AuthenticationService) { }

    canActivate() {
        if (this.auth.authenticated() && 
        (this.auth.isInRole("Moderator") || this.auth.isInRole("Admin") )) {
            return true;
        }

        this.router.navigate(["/user"]);
        return false;
    }
}